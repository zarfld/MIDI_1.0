# Requirements Elicitation Session: MIDI 1.0 Core Protocol

**Date**: 2025-11-26
**Stakeholder**: Project Lead / Standards Implementer
**Session ID**: ELICIT-20251126-001
**Parent Stakeholder Requirement**: Issue #277 (STR-MIDI-277: MIDI 1.0 Detailed Specification Compliance)
**Phase**: 02 - Requirements Analysis & Specification
**Standard**: ISO/IEC/IEEE 29148:2018 (Requirements Engineering)

---

## ðŸ“‹ Session Context

### Stakeholder Requirement Summary
Implement complete MIDI 1.0 Detailed Specification v4.2.1 (1996 revision) compliance including all 28 message types, protocol behaviors, and timing requirements as a hardware-agnostic C++ library.

### Architectural Foundation (Already Established)
The following architectural decisions have been established in Phase 01 and constrain the requirements elicitation:

**From StR #337 (Hardware-Agnostic MIDI Architecture with UMP Core)**:
- âœ… **UMP as internal format**: All MIDI messages converted to/from Universal MIDI Packet (UMP) internally
- âœ… **Device abstraction**: MIDI Device and UMP Endpoint abstract hardware
- âœ… **Function Blocks**: MIDI 1.0 channels encapsulated in Function Blocks
- âœ… **MIDITransport interface**: Abstract transport with send/receive + JR timestamps
- âœ… **Hardware independence**: Zero vendor-specific code, compilable without hardware headers
- âœ… **Static allocation**: No dynamic allocation in real-time paths

**From StR #338 (Protocol Layering and Version Separation)**:
- âœ… **Namespace isolation**: `MMA::MIDI::_1_0::v1996` (MIDI 1.0) completely separate from `MMA::MIDI::_2_0::v2023` (MIDI 2.0)
- âœ… **Protocol specificity**: MIDI 1.0 uses 7-bit values, MIDI 2.0 uses 16/32-bit values (no mixing)
- âœ… **UMP message types**: MIDI 1.0 uses UMP Type 0x2, MIDI 2.0 uses Types 0x4/0x5
- âœ… **Translation layer**: Separate `MMA::MIDI::Translation` namespace for MIDI 1.0 â†” MIDI 2.0 conversion
- âœ… **High-resolution internal state**: 32-bit internal state prevents precision loss
- âœ… **Consolidated amendments**: All addenda/corrigenda integrated into v1996 (INCLUDING ALL sub-versions)

**From StR #340 (Media Standards Library Integration)**:
- âœ… **Shared Kernel abstractions**: IClock, ITransport, IEndpoint, DeviceIdentity reused across standards
- âœ… **C++ standards**: C++17/C++20, fixed-size types (`std::uint8_t`, `std::uint16_t`, `std::uint32_t`)
- âœ… **Build system**: CMake with modular structure
- âœ… **Testing framework**: Google Test + Unity, >80% coverage target

These decisions **constrain and guide** the detailed requirements below.

### Scope of This Session
Transform high-level stakeholder requirement into detailed functional requirements (REQ-F) and non-functional requirements (REQ-NF) for:
- **Channel Voice Messages** (8 types): Note On/Off, Polyphonic Key Pressure, Control Change, Program Change, Channel Pressure, Pitch Bend
- **Channel Mode Messages** (4 types): Local Control, All Notes Off, Omni Mode On/Off, Mono/Poly Mode
- **System Common Messages** (6 types): System Exclusive, MTC Quarter Frame, Song Position Pointer, Song Select, Tune Request, EOX
- **System Real-Time Messages** (6 types): Timing Clock, Start, Continue, Stop, Active Sensing, System Reset
- **Protocol Behaviors**: Running Status, Real-Time message insertion, status byte detection, data byte validation
- **Timing Requirements**: 31.25 kbaud serial rate, 320 microseconds per byte, jitter handling

---

## ðŸ” Questions Across 8 Dimensions

### 1. Functional Behavior ðŸ”§

#### 1.1 Message Parsing and Validation
**Q1.1.1**: For each of the 28 MIDI message types, what are the exact byte sequences (status byte + data bytes) that must be recognized?
- **Context**: MIDI 1.0 defines specific status byte ranges (0x80-0xFF for status, 0x00-0x7F for data)
- **Need to clarify**: Which status byte patterns trigger which message handlers?
- **Example**: Note On = 0x9n (where n = channel 0-15), followed by 2 data bytes (note number 0-127, velocity 0-127)

**Q1.1.2**: How should the parser handle **Running Status** optimization?
- **Context**: Running Status allows omitting status bytes in consecutive messages of same type
- **Need to clarify**: When should Running Status buffer be cleared? (e.g., after System Real-Time messages, after System Common messages except Real-Time)
- **Example**: Sequence `90 3C 64 3D 60` = Note On Ch1, Note 60, Vel 100, then Note 61, Vel 96 (using Running Status)

**Q1.1.3**: How should **Real-Time messages** (0xF8-0xFF) be handled when they interrupt other messages?
- **Context**: Real-Time messages can occur at ANY byte position, even mid-SysEx
- **Need to clarify**: Should parser pause current message parsing, process Real-Time immediately, then resume?
- **Example**: Sequence `F0 7E 00 F8 09 01 F7` = SysEx interrupted by Timing Clock (0xF8)

**Q1.1.4**: What validation rules apply to **data byte ranges** (0x00-0x7F)?
- **Context**: Data bytes must have bit 7 = 0, status bytes must have bit 7 = 1
- **Need to clarify**: Should invalid data bytes (0x80-0xFF) be rejected with error, or silently masked to 7 bits?
- **Example**: If parser receives `90 3C FF` (invalid velocity 0xFF), should it error or treat as `90 3C 7F`?

**Q1.1.5**: How should the parser differentiate between **Note On with velocity 0** and **Note Off**?
- **Context**: MIDI 1.0 allows Note On (0x9n) with velocity=0 to function as Note Off
- **Need to clarify**: Should parser convert Note On velocity=0 to Note Off internally, or preserve original message type?
- **Example**: `90 3C 00` can mean Note Off for note 60, but is it semantically equivalent to `80 3C 40`?

#### 1.2 Message Generation and Formatting
**Q1.2.1**: When generating MIDI messages, should the library automatically apply **Running Status** optimization?
- **Context**: Running Status reduces bandwidth by omitting repeated status bytes
- **Need to clarify**: Should this be always-on, opt-in, or configurable per transport?
- **Example**: Generating consecutive Note On messages: with Running Status `90 3C 64 3D 60` vs. without `90 3C 64 90 3D 60`

**Q1.2.2**: What byte-level API should be provided for **System Exclusive (SysEx)** message construction?
- **Context**: SysEx messages are variable length (0xF0 ... 0xF7), can be fragmented
- **Need to clarify**: Should library provide SysEx builder API, or just accept raw byte streams?
- **Example**: Should API be `sendSysEx(manufacturerId, data[], length)` or `sendBytes(F0, 7E, 00, ...)`?

**Q1.2.3**: How should **14-bit Control Change** messages be generated (MSB/LSB pairs)?
- **Context**: CC 0-31 are MSB, CC 32-63 are LSB for high-resolution control
- **Need to clarify**: Should library provide helper function to send 14-bit CC in correct order?
- **Example**: Sending Bank Select (CC 0 MSB = 0x02, CC 32 LSB = 0x10) requires two separate CC messages

**Q1.2.4**: What order should **RPN/NRPN message sequences** be generated?
- **Context**: RPN/NRPN require 4-message sequence: MSB, LSB, Data Entry, Null (0x7F 0x7F)
- **Need to clarify**: Should library enforce correct sequence order, or trust caller?
- **Example**: RPN Pitch Bend Range = `B0 65 00` (RPN MSB), `B0 64 00` (RPN LSB), `B0 06 0C` (Data Entry MSB = 12 semitones), `B0 65 7F` (Null MSB), `B0 64 7F` (Null LSB)

#### 1.3 Channel Mode Messages
**Q1.3.1**: How should **All Notes Off (CC 123)** and **All Sound Off (CC 120)** differ in behavior?
- **Context**: All Notes Off releases notes via Release phase, All Sound Off mutes immediately
- **Need to clarify**: Should library track note state to implement these correctly?
- **Example**: All Notes Off should trigger MIDI envelopes Release phase; All Sound Off should mute instantly

**Q1.3.2**: How should **Omni Mode On/Off** affect channel routing?
- **Context**: Omni On (CC 125) makes device respond to all channels, Omni Off (CC 124) restricts to assigned channel
- **Need to clarify**: Should library provide channel filter that respects Omni mode?
- **Example**: In Omni On mode, Note On on any channel should trigger sound

**Q1.3.3**: What state changes occur when **Mono Mode On (CC 126)** or **Poly Mode On (CC 127)** are received?
- **Context**: Mono Mode limits to 1 note per channel, Poly Mode allows multiple simultaneous notes
- **Need to clarify**: Should library enforce voice allocation rules, or just signal mode change?
- **Example**: Mono Mode with 4 channels = 4 voices (one per channel); Poly Mode = all 16 channels share voice pool

---

### 2. Boundary Values & Ranges ðŸ“

#### 2.1 Data Range Limits
**Q2.1.1**: What are the **exact numerical ranges** for each MIDI data type?
- **Channel Number**: 0-15 (4 bits) or 1-16 (human-readable)?
- **Note Number**: 0-127 (MIDI Note 0 = C-1, MIDI Note 127 = G9)?
- **Velocity**: 0-127 (0 = Note Off in Note On messages, 1-127 = attack velocity)?
- **Control Change Value**: 0-127 (7-bit resolution)?
- **Program Change Number**: 0-127 (program 0-127)?
- **Pitch Bend**: 0-16383 (14-bit, center = 8192)?
- **Channel Pressure**: 0-127 (aftertouch)?
- **Polyphonic Key Pressure**: 0-127 per note?

**Q2.1.2**: What are the **minimum and maximum values** for timing-related parameters?
- **MIDI Timing Clock (0xF8)**: 24 pulses per quarter note (PPQN)
- **Song Position Pointer**: 0-16383 (14-bit, position in MIDI beats)
- **Tempo**: Derived from interval between Timing Clock messages (external to MIDI protocol)
- **Active Sensing timeout**: 300 milliseconds typical (if Active Sensing enabled)

**Q2.1.3**: What are the **SysEx message length limits**?
- **Minimum SysEx length**: 2 bytes (0xF0 0xF7 = empty SysEx)?
- **Maximum SysEx length**: Unlimited by spec, but practical limit? (e.g., 64KB, 1MB?)
- **Fragmentation handling**: If SysEx exceeds buffer size, how should fragments be handled?

#### 2.2 Edge Cases
**Q2.2.1**: How should parser handle **incomplete messages** (e.g., status byte without required data bytes)?
- **Example**: Receive `90 3C` (Note On, note 60, but missing velocity byte) before timeout or next status byte
- **Behavior options**: Buffer and wait for completion? Discard as malformed? Signal incomplete state?

**Q2.2.2**: How should parser handle **rapid message bursts** exceeding processing capacity?
- **Context**: At 31.25 kbaud, MIDI can send ~3125 bytes/second (~1000 3-byte messages/second)
- **Need to clarify**: Should library use ring buffer with overflow detection, or block when full?

**Q2.2.3**: What happens when **Running Status is broken** by System Common message?
- **Context**: System Common messages (except Real-Time) clear Running Status buffer
- **Example**: Sequence `90 3C 64 F3 05 3D 60` = Note On, Song Select (clears Running Status), then `3D 60` is invalid (no status)
- **Behavior**: Should parser detect this and raise error?

**Q2.2.4**: How should parser handle **reserved status bytes** (0xF4, 0xF5, 0xF9, 0xFD)?
- **Context**: MIDI 1.0 reserves these status bytes for future use (undefined)
- **Behavior options**: Ignore silently? Log warning? Raise error?

---

### 3. Error Handling & Validation âš ï¸

#### 3.1 Parse-Time Errors
**Q3.1.1**: What **error conditions** must be detected during message parsing?
1. **Invalid Status Byte**: Byte with bit 7 = 0 received when expecting status
2. **Invalid Data Byte**: Byte with bit 7 = 1 received when expecting data
3. **Incomplete Message**: Timeout or next status before all data bytes received
4. **Reserved Status Byte**: 0xF4, 0xF5, 0xF9, 0xFD received
5. **SysEx Termination Error**: SysEx missing EOX (0xF7) before timeout or next status
6. **Buffer Overflow**: Incoming message exceeds available buffer space

**Q3.1.2**: How should each error be **communicated to the caller**?
- **Return code**: Error enum (`MIDI_ERROR_INVALID_STATUS`, `MIDI_ERROR_INCOMPLETE_MESSAGE`, etc.)?
- **Exception**: Throw exception (not real-time safe)?
- **Callback**: Error handler callback function?
- **Logging**: Log to diagnostic stream and continue?

**Q3.1.3**: What **recovery actions** are appropriate for each error type?
- **Invalid Status/Data Byte**: Discard byte and attempt resynchronization at next status byte?
- **Incomplete Message**: Discard partial message and reset parser state?
- **Buffer Overflow**: Drop oldest messages (FIFO), or block new messages?

#### 3.2 Validation Rules
**Q3.2.1**: Should the library validate **semantically invalid** but syntactically correct messages?
- **Example 1**: Note On velocity = 0 (valid syntax, but typically indicates Note Off)
- **Example 2**: Control Change 120-127 (Channel Mode messages, not general CCs)
- **Example 3**: Program Change > 127 (impossible with 7-bit data byte, but could be checked)
- **Question**: Should library warn about these, or trust caller to send correct messages?

**Q3.2.2**: Should the library enforce **manufacturer-specific SysEx ID validation**?
- **Context**: SysEx Manufacturer ID (1-byte: 0x01-0x7D, or 3-byte: 0x00 + 2 bytes)
- **Question**: Should library validate Manufacturer ID against registered list, or accept any 7-bit value?
- **Example**: SysEx `F0 7D 00 01 F7` uses educational ID 0x7D (reserved for non-commercial use)

**Q3.2.3**: What validation is needed for **Universal SysEx messages** (ID 0x7E Non-Real-Time, 0x7F Real-Time)?
- **Context**: Universal SysEx have standardized sub-ID structures (device ID, sub-ID #1, sub-ID #2)
- **Question**: Should library parse and validate Universal SysEx sub-IDs, or treat as opaque data?
- **Example**: General MIDI System On = `F0 7E 7F 09 01 F7` (Universal Non-Real-Time, device ID=7F, sub-ID1=09, sub-ID2=01)

---

### 4. Performance & Scalability âš¡

#### 4.1 Real-Time Performance
**Q4.1.1**: What **maximum latency** is acceptable for message parsing?
- **Context**: MIDI byte time = 320 microseconds at 31.25 kbaud
- **Target**: Parse and dispatch message within N microseconds?
- **Constraint**: Real-time audio systems typically require <10ms latency (44.1kHz sample rate = ~22.6Î¼s per sample)
- **Question**: Should parser aim for <10Î¼s per message to avoid audio glitches?

**Q4.1.2**: What **throughput** must the parser sustain?
- **Context**: MIDI 1.0 maximum bandwidth = 31.25 kbaud = 3125 bytes/second
- **Scenario 1**: Dense Note On/Off stream = ~1000 messages/second (3 bytes each)
- **Scenario 2**: SysEx bulk dump = ~3KB/second sustained
- **Question**: Should parser handle sustained 3125 bytes/second without dropping messages?

**Q4.1.3**: What **memory allocation constraints** apply for real-time use?
- **Constraint**: Real-time audio must avoid dynamic allocation (malloc/new) in audio thread
- **âœ… ALREADY DECIDED** (per StR #337 - Hardware-Agnostic Architecture):
  - **Static allocation only**: No dynamic allocation in real-time critical paths
  - **Success metric**: Zero dynamic allocation in message parsing/generation
  - **Fixed-size buffers**: Pre-allocated ring buffers for MIDI byte streams
- **Question remaining**: What default buffer sizes should be provided? (e.g., 1KB for incoming MIDI bytes, 256 bytes for SysEx reassembly)

**Q4.1.4**: What **CPU overhead** is acceptable for MIDI processing?
- **Context**: In real-time audio system, MIDI processing is secondary to audio DSP
- **Target**: MIDI processing should consume <1% of CPU budget on target hardware (ARM Cortex-M7 @ 480MHz)?
- **Question**: How should CPU usage be measured and validated?

#### 4.2 Concurrency and Thread Safety
**Q4.2.1**: Should the MIDI parser be **thread-safe** for concurrent access?
- **Scenario 1**: MIDI receive thread writes to parser, audio thread reads parsed messages
- **Scenario 2**: Multiple MIDI input ports parsed concurrently
- **Question**: Should parser use locks, lock-free data structures, or single-threaded design?

**Q4.2.2**: How should **multi-port MIDI** be handled?
- **Context**: Device may have multiple MIDI inputs/outputs (e.g., USB MIDI with 16 virtual ports)
- **Question**: Should each port have independent parser instance, or share parser with port tagging?

---

### 5. Security & Privacy ðŸ”’

#### 5.1 Input Validation and Sanitization
**Q5.1.1**: How should the library protect against **malformed MIDI streams**?
- **Attack 1**: Excessive SysEx length (e.g., 1GB SysEx to exhaust memory)
- **Attack 2**: Rapid status byte spam (e.g., 1000 0xFF bytes/second to trigger Active Sensing false positives)
- **Attack 3**: Invalid byte sequences to trigger buffer overflows
- **Question**: Should library enforce maximum message lengths and rate limits?

**Q5.1.2**: Should the library validate **SysEx content for known exploits**?
- **Context**: Some MIDI devices have had firmware upload vulnerabilities via SysEx
- **Question**: Should library provide hooks for application-level SysEx content filtering?

#### 5.2 Access Control
**Q5.2.1**: Should the library provide **channel-level access control**?
- **Scenario**: Multi-user MIDI system where User A should only send on channels 1-4, User B on 5-8
- **Question**: Should library enforce channel restrictions, or trust caller to filter?

**Q5.2.2**: Should the library restrict **dangerous MIDI messages** in certain contexts?
- **Example**: All Sound Off (CC 120) could disrupt live performance if sent maliciously
- **Question**: Should library provide opt-in blocking of specific message types?

---

### 6. Integration & Dependencies ðŸ”—

#### 6.1 Transport Abstraction
**Q6.1.1**: What **hardware abstraction layer (HAL)** interface should the parser use for byte I/O?
- **Required operations**: `send_byte(uint8_t)`, `receive_byte(uint8_t*)`, `bytes_available()`
- **âœ… ALREADY DECIDED** (per StR #337 - Hardware-Agnostic Architecture):
  - **MIDITransport interface**: Abstract base with `send()`, `receive()`, `available()` methods
  - **JR Timestamps**: All messages timestamped with Jitter-Reduction timestamps (UMP format)
  - **Hardware independence**: No vendor-specific code, dependency injection pattern
- **âœ… ANSWERED**: HAL **SHALL provide** timing functions (`get_time_us()`, `set_timer()`) for Active Sensing timeout detection (300ms typical)
  - **Rationale**: Active Sensing timeout is protocol-level behavior requiring precise timing

**Q6.1.2**: How should the library support **multiple MIDI transports** (5-pin DIN, USB, BLE, Ethernet)?
- **Context**: Each transport has different framing (5-pin DIN = raw bytes, USB = 4-byte packets)
- **âœ… ALREADY DECIDED** (per StR #337 - Hardware-Agnostic Architecture):
  - **Transport-agnostic core**: Standards layer (MMA::MIDI namespace) has ZERO transport dependencies
  - **Transport adapters**: Service layer implements transport-specific adapters (USB, BLE, Network)
  - **Dependency injection**: Application injects transport implementation via MIDITransport interface
- **âœ… ANSWERED**: Reference implementation **examples SHALL be provided** (Priority P2)
  - **Scope**: Example transport adapters for 5-pin DIN, USB MIDI, BLE-MIDI in documentation/examples folder
  - **Purpose**: Educational use cases, integration testing, developer onboarding
  - **Not in critical path**: Examples are P2 (after core Standards layer P0/P1 implementation)

**Q6.1.3**: Should the library provide **MIDI routing and merging** functionality?
- **Scenario 1**: Merge multiple MIDI inputs to single output
- **Scenario 2**: Route messages by channel to different outputs
- **Question**: Should this be in-scope for core library, or separate module?

#### 6.2 External System Integration
**Q6.2.1**: How should the library integrate with **MIDI Time Code (MTC)** for synchronization?
- **Context**: MTC uses MIDI Quarter Frame messages (0xF1) and Full Frame SysEx
- **Question**: Should core parser just expose raw MTC messages, or provide MTC decoding API?

**Q6.2.2**: How should the library integrate with **General MIDI (GM) sound sets**?
- **Context**: GM defines 128 standard instruments and drum kits
- **Question**: Should library provide GM instrument name lookup, or just pass Program Change numbers?

**Q6.2.3**: What **data exchange formats** should be supported beyond real-time MIDI?
- **Standard MIDI File (SMF)**: Should library parse/generate .mid files?
- **JSON MIDI**: Should library provide JSON serialization for web APIs?
- **Question**: Are these in-scope for MIDI 1.0 core library, or separate modules?

---

### 7. User Experience & Accessibility â™¿

#### 7.1 API Design and Usability
**Q7.1.1**: What **API style** should the library provide?
- **Option A**: Low-level byte-oriented API: `parser.parse_byte(0x90)`, `parser.parse_byte(0x3C)`, `parser.parse_byte(0x64)`
- **Option B**: High-level message-oriented API: `parser.parse_message(NoteOnMessage{channel=0, note=60, velocity=100})`
- **Option C**: Callback-based API: `parser.on_note_on([](channel, note, vel) { /* handle */ })`
- **Question**: Should library provide all three styles, or focus on one?

**Q7.1.2**: How should **MIDI channel numbering** be presented to users?
- **Internal**: 0-15 (4-bit value in status byte)
- **User-facing**: 1-16 (human-readable convention)
- **Question**: Should API use 0-based or 1-based channel numbers? Document convention clearly?

**Q7.1.3**: What **documentation and examples** are required?
- **API Reference**: Doxygen comments for all public functions?
- **Tutorial**: "Hello MIDI" example (parse Note On/Off)?
- **Cookbook**: Common patterns (send Program Change, handle RPN/NRPN)?
- **Question**: What documentation priority and format?

#### 7.2 Developer Experience
**Q7.2.1**: What **debugging and diagnostics** should be provided?
- **MIDI message logging**: Hex dump of all messages?
- **Parser state inspection**: Current Running Status, partial message buffer?
- **Performance profiling**: Message parse time histogram?
- **Question**: Should diagnostics be always-on, opt-in, or compile-time configurable?

**Q7.2.2**: How should **error messages** be formatted for clarity?
- **Example**: "Parse error: Invalid data byte 0x90 at offset 42, expected value 0x00-0x7F"
- **Question**: Should errors include context (message type, byte offset, expected vs. actual)?

---

### 8. Compliance & Regulations ðŸ“‹

#### 8.1 MIDI Specification Compliance
**Q8.1.1**: Which **version of MIDI 1.0 specification** should be implemented?
- **Core**: MIDI 1.0 Detailed Specification v4.2.1 (1996 revision)
- **Extensions**: Which addenda and recommended practices (RPs) are mandatory?
  - RP-015: Response to Reset All Controllers
  - RP-018: Response to Data Inc/Dec Controllers
  - RP-021: Sound Controller Defaults
  - RP-023: Renaming of CC91 and CC93
- **âœ… ALREADY DECIDED** (per StR #338 - Protocol Layering):
  - **Full coverage**: All MIDI 1.0 specifications, extensions, and RPs will be implemented
  - **Namespace separation**: `MMA::MIDI::_1_0::v1996` for MIDI 1.0 Detailed Spec (1996 revision)
  - **Version isolation**: MIDI 1.0 and MIDI 2.0 will be completely separate namespaces with no cross-references
  - **Consolidated amendments**: All addenda/corrigenda will be integrated into v1996 namespace (INCLUDING ALL sub-versions)
  - **Question remaining**: Which specific RPs are P0 (critical) vs. P1 (high) vs. P2 (medium) priority for Phase 05 implementation order?

**Q8.1.2**: How should the library handle **deprecated MIDI features**?
- **Example**: Undefined status bytes (0xF4, 0xF5, 0xF9, 0xFD)
- **Example**: Obsolete Channel Mode messages (e.g., Local Control On/Off rarely used)
- **Question**: Should deprecated features be implemented for completeness, or omitted with warnings?

#### 8.2 Intellectual Property Compliance
**Q8.2.1**: How should the library respect **MIDI trademark and copyright**?
- **Trademark**: "MIDI" is registered trademark of MIDI Manufacturers Association (MMA)
- **Copyright**: MIDI specifications copyrighted by MMA/AMEI
- **Question**: What copyright notices and attribution are required in source code and documentation?

**Q8.2.2**: What **SysEx Manufacturer ID restrictions** must be enforced?
- **Reserved ID 0x7D**: Educational use only (non-commercial)
- **ID Assignment**: Manufacturer IDs assigned by MMA (https://www.midi.org/specifications-old/item/manufacturer-id-numbers)
- **Question**: Should library warn when using reserved or unregistered IDs?

#### 8.3 Testing and Conformance
**Q8.3.1**: What **conformance test suite** should be used to validate MIDI 1.0 compliance?
- **Test Cases**: Parse all 28 message types correctly?
- **Test Cases**: Handle Running Status per specification?
- **Test Cases**: Validate data byte ranges?
- **Question**: Should library include conformance test suite, or reference external tests?

**Q8.3.2**: How should **interoperability** with existing MIDI devices be verified?
- **Test Devices**: Test with hardware MIDI interfaces (e.g., Roland UM-ONE, M-Audio USB MIDI)?
- **Test Devices**: Test with software MIDI implementations (e.g., LoopMIDI virtual ports)?
- **Question**: What interoperability test plan is required?

---

## ðŸ“ Stakeholder Responses

**SECTION FOR STAKEHOLDER TO COMPLETE**

Please answer the questions above to provide detailed requirements. For each question:

1. **Provide specific answer** (not "to be determined")
2. **Include examples** where helpful
3. **Identify any constraints** (technical, business, regulatory)
4. **Flag any questions** that need further research or stakeholder discussion

**Note**: Questions marked **âœ… ALREADY DECIDED** have been answered by architectural decisions in StR #337, #338, and #340. You may skip these unless you want to refine or clarify specific aspects.

### Response Template

#### 1. Functional Behavior ðŸ”§
**Q1.1.1 Answer**: [Your answer here]
**Q1.1.2 Answer**: [Your answer here]
[Continue for all Q1.x.x...]

#### 2. Boundary Values & Ranges ðŸ“
**Q2.1.1 Answer**: [Your answer here]
[Continue...]

#### 3. Error Handling & Validation âš ï¸
[Continue...]

#### 4. Performance & Scalability âš¡
[Continue...]

#### 5. Security & Privacy ðŸ”’
[Continue...]

#### 6. Integration & Dependencies ðŸ”—
[Continue...]

#### 7. User Experience & Accessibility â™¿
[Continue...]

#### 8. Compliance & Regulations ðŸ“‹
[Continue...]

---

## ðŸ“Š Next Steps After Responses Received

Once stakeholder provides answers:

1. **Generate REQ-F Issues** (Functional Requirements):
   - REQ-F-MIDI-PARSE-001: Channel Voice Message Parsing
   - REQ-F-MIDI-PARSE-002: Running Status Implementation
   - REQ-F-MIDI-PARSE-003: Real-Time Message Handling
   - REQ-F-MIDI-GEN-001: Message Generation API
   - REQ-F-MIDI-SYSEX-001: System Exclusive Message Handling
   - REQ-F-MIDI-MODE-001: Channel Mode Message Handling
   - [10-15 functional requirements estimated]

2. **Generate REQ-NF Issues** (Non-Functional Requirements):
   - REQ-NF-MIDI-PERF-001: Message Parse Latency (<10Î¼s target)
   - REQ-NF-MIDI-PERF-002: Throughput (3125 bytes/second sustained)
   - REQ-NF-MIDI-RELI-001: Memory Allocation (static allocation only)
   - REQ-NF-MIDI-SECU-001: Input Validation (malformed stream protection)
   - REQ-NF-MIDI-COMP-001: MIDI 1.0 Specification Compliance
   - REQ-NF-MIDI-PORT-001: Hardware Abstraction (no vendor-specific code)
   - [6-10 non-functional requirements estimated]

3. **Establish Traceability**:
   - All REQ-F/REQ-NF issues will trace back to StR #277
   - Architecture decisions (ADRs) will reference REQ issues
   - Test cases (TEST issues) will verify REQ issues

4. **Create GitHub Issues** with complete templates including:
   - Requirement statement (The system shall...)
   - Rationale (business justification)
   - Detailed specification (inputs, processing rules, outputs)
   - Acceptance criteria (Gherkin Given/When/Then scenarios)
   - Traceability links (Traces to: #277)

---

## ðŸ“š References

- **MIDI 1.0 Detailed Specification v4.2.1** (1996): `/docs/MIDI1.0_Specs/M1_v4-2-1_MIDI_1-0_Detailed_Specification_96-1-4.pdf`
- **ISO/IEC/IEEE 29148:2018**: Requirements engineering processes and lifecycle
- **Phase 02 Instructions**: `.github/instructions/phase-02-requirements.instructions.md`
- **Requirements Elicitation Prompt**: `.github/prompts/requirements-elicit.prompt.md`
- **Parent Stakeholder Requirement**: Issue #277 (STR-MIDI-277)

---

**Status**: â³ **Awaiting Stakeholder Responses**

Once responses received, this session will generate 20-25 detailed requirement issues (REQ-F and REQ-NF) that form the foundation for Phase 03 (Architecture Design) and Phase 05 (Implementation).
